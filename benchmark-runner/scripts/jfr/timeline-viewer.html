<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Netty Loom Timeline Viewer</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f4f1ea;
      --panel: #fff9f0;
      --ink: #1d1b16;
      --muted: #6a6257;
      --accent: #d97706;
      --accent-2: #0f766e;
      --grid: rgba(0, 0, 0, 0.08);
      --lane: rgba(0, 0, 0, 0.05);
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Space Grotesk", "IBM Plex Sans", "Segoe UI", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 20% 10%, rgba(217, 119, 6, 0.12), transparent 40%),
        radial-gradient(circle at 80% 0%, rgba(15, 118, 110, 0.16), transparent 45%),
        var(--bg);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 20px 28px 10px;
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }

    header h1 {
      margin: 0;
      font-weight: 600;
      letter-spacing: -0.02em;
      font-size: 20px;
    }

    .panel {
      background: var(--panel);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 16px;
    }

    .toolbar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      padding: 0 28px 16px;
    }

    label {
      display: block;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-bottom: 6px;
    }

    input[type="text"], input[type="number"], input[type="range"] {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      font-size: 14px;
      background: #fff;
      color: var(--ink);
    }

    input[type="file"] {
      width: 100%;
    }

    button {
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 10px;
      padding: 8px 12px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    button.secondary {
      background: var(--accent-2);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .stats {
      font-family: "JetBrains Mono", "IBM Plex Mono", monospace;
      font-size: 12px;
      color: var(--muted);
      padding: 0 28px 14px;
    }

    .viewer {
      display: grid;
      grid-template-rows: 80px 1fr;
      gap: 12px;
      padding: 0 28px 28px;
      flex: 1;
    }

    .overview, .timeline {
      background: #fff;
      border-radius: 14px;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .overview canvas, .timeline canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .timeline {
      display: flex;
      flex-direction: column;
    }

    .timeline .scroll {
      overflow: auto;
      flex: 1;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 12px;
      font-size: 12px;
      padding: 12px 20px 0;
      color: var(--muted);
    }

    .legend label {
      text-transform: none;
      letter-spacing: normal;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin: 0;
    }

    .legend input[type="checkbox"] {
      accent-color: var(--accent);
    }

    #tooltip {
      position: fixed;
      pointer-events: none;
      background: rgba(29, 27, 22, 0.9);
      color: #fff;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      font-family: "JetBrains Mono", "IBM Plex Mono", monospace;
      opacity: 0;
      transform: translate(-50%, -100%);
      transition: opacity 120ms ease;
      z-index: 10;
      max-width: 520px;
      white-space: pre;
    }
  </style>
</head>
<body>
  <header>
    <h1>Netty Loom Timeline Viewer</h1>
    <div class="panel">Load a `timeline.jsonl` or `timeline.jsonl.gz` generated by `JfrToTimeline.java`.</div>
  </header>

  <section class="toolbar">
    <div class="panel">
      <label>Timeline File</label>
      <input id="fileInput" type="file" accept=".jsonl,.jsonl.gz,.ntl,.ntl.gz">
    </div>
    <div class="panel">
      <label>Thread Filter</label>
      <input id="threadFilter" type="text" placeholder="contains">
    </div>
    <div class="panel">
      <label>Min Duration (ns)</label>
      <input id="minDuration" type="number" min="0" value="0">
    </div>
    <div class="panel">
      <label>Range Controls</label>
      <div style="display:flex; gap:8px; flex-wrap:wrap;">
        <button id="zoomSelection">Zoom to Selection</button>
        <button id="resetZoom" class="secondary">Reset</button>
        <button id="resetOrder" class="secondary">Reset Order</button>
      </div>
    </div>
  </section>

  <div class="stats" id="stats">No data loaded.</div>

  <section class="viewer">
    <div class="overview panel">
      <canvas id="overviewCanvas"></canvas>
    </div>
    <div class="timeline panel">
      <div class="legend" id="legend"></div>
      <div class="scroll" id="scrollArea">
        <canvas id="timelineCanvas"></canvas>
      </div>
    </div>
  </section>

  <div id="tooltip"></div>

  <script>
    const state = {
      events: [],
      eventEnabled: [],
      threads: new Map(),
      threadOrder: [],
      defaultThreadOrder: [],
      minMicros: 0,
      maxMicros: 0,
      count: 0,
      viewStart: 0,
      viewEnd: 0,
      timeUnit: 'us',
      timeScale: 1_000,
      selection: null,
      laneHeight: 12,
      minLaneHeight: 6,
      maxLaneHeight: 28,
      carrierLabelWidth: 180,
      eventLabelWidth: 170,
      labelGap: 12,
      visibleRows: [],
      overviewReady: false,
    };

    const fileInput = document.getElementById('fileInput');
    const stats = document.getElementById('stats');
    const legend = document.getElementById('legend');
    const overviewCanvas = document.getElementById('overviewCanvas');
    const timelineCanvas = document.getElementById('timelineCanvas');
    const scrollArea = document.getElementById('scrollArea');
    const tooltip = document.getElementById('tooltip');
    const threadFilter = document.getElementById('threadFilter');
    const minDuration = document.getElementById('minDuration');
    const zoomSelection = document.getElementById('zoomSelection');
    const resetZoom = document.getElementById('resetZoom');
    const resetOrder = document.getElementById('resetOrder');
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const snap = (value) => Math.round(value * dpr) / dpr;

    fileInput.addEventListener('change', () => {
      const file = fileInput.files[0];
      if (file) {
        loadTimeline(file);
      }
    });

    threadFilter.addEventListener('input', () => redraw());
    minDuration.addEventListener('input', () => redraw());
    zoomSelection.addEventListener('click', () => {
      if (!state.selection) return;
      state.viewStart = state.selection.start;
      state.viewEnd = state.selection.end;
      state.selection = null;
      redraw();
    });
    resetZoom.addEventListener('click', () => {
      state.viewStart = state.minMicros;
      state.viewEnd = state.maxMicros;
      state.selection = null;
      redraw();
    });
    resetOrder.addEventListener('click', () => {
      if (state.defaultThreadOrder.length) {
        state.threadOrder = state.defaultThreadOrder.slice();
      } else {
        state.threadOrder = state.threadOrder.slice().sort((a, b) => {
          const ta = state.threads.get(a);
          const tb = state.threads.get(b);
          return ta.name.localeCompare(tb.name) || ta.tid - tb.tid;
        });
      }
      redraw(true);
    });

    function resetState() {
      state.events = [];
      state.eventEnabled = [];
      state.threads.clear();
      state.threadOrder = [];
      state.defaultThreadOrder = [];
      state.minMicros = 0;
      state.maxMicros = 0;
      state.count = 0;
      state.viewStart = 0;
      state.viewEnd = 0;
      state.timeUnit = 'us';
      state.timeScale = 1_000;
      state.selection = null;
      state.overviewReady = false;
      legend.innerHTML = '';
    }

    function setStats(message) {
      stats.textContent = message;
    }

    function updateLegend() {
      legend.innerHTML = '';
      state.events.forEach((name, idx) => {
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = state.eventEnabled[idx];
        checkbox.addEventListener('change', () => {
          state.eventEnabled[idx] = checkbox.checked;
          redraw();
        });
        const swatch = document.createElement('span');
        swatch.style.width = '10px';
        swatch.style.height = '10px';
        swatch.style.display = 'inline-block';
        swatch.style.borderRadius = '3px';
        swatch.style.background = eventColor(idx);
        label.appendChild(checkbox);
        label.appendChild(swatch);
        label.appendChild(document.createTextNode(name));
        legend.appendChild(label);
      });
    }

    function eventColor(idx) {
      const hue = (idx * 63) % 360;
      return `hsl(${hue} 70% 45%)`;
    }

    const VT_RUN_EVENT_NAME = 'VirtualThreadTaskRun';
    const VT_SUBMIT_EVENT_NAME = 'VirtualThreadTaskSubmit';
    const VT_RUN_COLORS = {
      poller: '#e11d48',
      eventLoop: '#2563eb',
      immediate: '#f59e0b',
    };
    const VT_RUN_COMBO = mixColors(VT_RUN_COLORS.poller, VT_RUN_COLORS.immediate);

    function mixColors(hexA, hexB) {
      const a = hexToRgb(hexA);
      const b = hexToRgb(hexB);
      const mix = {
        r: Math.round((a.r + b.r) / 2),
        g: Math.round((a.g + b.g) / 2),
        b: Math.round((a.b + b.b) / 2),
      };
      return `rgb(${mix.r}, ${mix.g}, ${mix.b})`;
    }

    function hexToRgb(hex) {
      const clean = hex.replace('#', '');
      const value = clean.length === 3
        ? clean.split('').map(c => c + c).join('')
        : clean;
      const intVal = parseInt(value, 16);
      return {
        r: (intVal >> 16) & 255,
        g: (intVal >> 8) & 255,
        b: intVal & 255,
      };
    }

    function carrierColor(tid) {
      const hue = (tid * 29) % 360;
      return `hsl(${hue} 50% 55%)`;
    }

    async function loadTimeline(file) {
      resetState();
      setStats('Loading...');

      let stream = file.stream();
      if (file.name.endsWith('.gz') && 'DecompressionStream' in window) {
        stream = stream.pipeThrough(new DecompressionStream('gzip'));
      }

      const reader = stream.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      let bytes = 0;

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        bytes += value.length;
        buffer += decoder.decode(value, { stream: true });
        let index;
        while ((index = buffer.indexOf('\n')) >= 0) {
          const line = buffer.slice(0, index);
          buffer = buffer.slice(index + 1);
          parseLine(line);
        }
        if (bytes % (10 * 1024 * 1024) < value.length) {
          setStats(`Loading... ${formatBytes(bytes)} processed`);
        }
      }
      buffer += decoder.decode();
      if (buffer.trim().length > 0) {
        parseLine(buffer.trim());
      }

      finalizeState();
      setStats(summaryText());
      redraw(true);
    }

    function parseLine(line) {
      if (!line) return;
      const obj = JSON.parse(line);
      switch (obj.t) {
        case 'h':
          state.events = obj.events || [];
          state.eventEnabled = state.events.map(() => true);
          state.timeUnit = obj.unit || 'us';
          state.timeScale = unitToNanos(state.timeUnit);
          updateLegend();
          break;
        case 'm': {
          const thread = getThread(obj.tid);
          thread.name = obj.name || thread.name;
          break;
        }
        case 'e': {
          const thread = getThread(obj.tid);
          const start = obj.s * state.timeScale;
          const dur = obj.d * state.timeScale;
          thread.s.push(start);
          thread.d.push(dur);
          thread.n.push(obj.n);
          thread.v.push(obj.v || 0);
          thread.p.push(obj.p ?? null);
          thread.el.push(obj.el ?? null);
          thread.im.push(obj.im ?? null);
          thread.b.push(obj.b ?? null);
          thread.te.push(obj.te ?? null);
          thread.q0.push(obj.q0 ?? null);
          thread.q1.push(obj.q1 ?? null);
          thread.io.push(obj.io ?? null);
          thread.th.push(obj.th ?? null);
          thread.st.push(obj.st ?? null);
          state.count += 1;
          if (!state.minMicros || start < state.minMicros) state.minMicros = start;
          const end = start + dur;
          if (end > state.maxMicros) state.maxMicros = end;
          break;
        }
        case 'f':
          if (obj.min != null) state.minMicros = obj.min * state.timeScale;
          if (obj.max != null) state.maxMicros = obj.max * state.timeScale;
          break;
        default:
          break;
      }
    }

    function getThread(tid) {
      let thread = state.threads.get(tid);
      if (!thread) {
        thread = { tid, name: `tid-${tid}`, s: [], d: [], n: [], v: [], p: [], el: [], im: [], b: [], te: [], q0: [], q1: [], io: [], th: [], st: [] };
        state.threads.set(tid, thread);
      }
      return thread;
    }

    function finalizeState() {
      state.threadOrder = Array.from(state.threads.values())
        .sort((a, b) => a.name.localeCompare(b.name) || a.tid - b.tid)
        .map(thread => thread.tid);
      state.defaultThreadOrder = state.threadOrder.slice();
      for (const thread of state.threads.values()) {
        const count = thread.s.length;
        const order = Array.from({ length: count }, (_, i) => i);
        order.sort((a, b) => thread.s[a] - thread.s[b]);
        thread.s = order.map(i => thread.s[i]);
        thread.d = order.map(i => thread.d[i]);
        thread.n = order.map(i => thread.n[i]);
        thread.v = order.map(i => thread.v[i]);
        thread.p = order.map(i => thread.p[i]);
        thread.el = order.map(i => thread.el[i]);
        thread.im = order.map(i => thread.im[i]);
        thread.b = order.map(i => thread.b[i]);
        thread.te = order.map(i => thread.te[i]);
        thread.q0 = order.map(i => thread.q0[i]);
        thread.q1 = order.map(i => thread.q1[i]);
        thread.io = order.map(i => thread.io[i]);
        thread.th = order.map(i => thread.th[i]);
        thread.st = order.map(i => thread.st[i]);
      }
      state.viewStart = state.minMicros;
      state.viewEnd = state.maxMicros;
    }

    function summaryText() {
      const durationNs = Math.max(0, state.maxMicros - state.minMicros);
      return `Threads: ${state.threadOrder.length} | Events: ${state.count} | Range: ${formatDuration(durationNs)}`;
    }

    function unitToNanos(unit) {
      switch ((unit || '').toLowerCase()) {
        case 'ns':
          return 1;
        case 'us':
          return 1_000;
        case 'ms':
          return 1_000_000;
        case 's':
          return 1_000_000_000;
        default:
          return 1;
      }
    }

    function formatDuration(nanos) {
      const abs = Math.abs(nanos);
      if (abs < 1_000) return `${nanos} ns`;
      if (abs < 1_000_000) return `${(nanos / 1_000).toFixed(3)} us`;
      if (abs < 1_000_000_000) return `${(nanos / 1_000_000).toFixed(3)} ms`;
      if (abs < 60_000_000_000) return `${(nanos / 1_000_000_000).toFixed(3)} s`;
      const minutes = nanos / 60_000_000_000;
      if (Math.abs(minutes) < 60) return `${minutes.toFixed(3)} min`;
      const hours = minutes / 60;
      return `${hours.toFixed(3)} h`;
    }

    function formatNanosRaw(nanos) {
      return `${nanos} ns`;
    }

    function formatBytes(bytes) {
      const units = ['B', 'KB', 'MB', 'GB'];
      let i = 0;
      let value = bytes;
      while (value >= 1024 && i < units.length - 1) {
        value /= 1024;
        i++;
      }
      return `${value.toFixed(1)} ${units[i]}`;
    }

    function redraw(forceResize) {
      if (!state.threadOrder.length) return;
      const visibleThreads = filteredThreadOrder();
      const visibleRows = buildVisibleRows(visibleThreads);
      state.visibleRows = visibleRows;
      const canvasWidth = timelineCanvas.clientWidth;
      const availableHeight = Math.max(1, scrollArea.clientHeight);
      const fittedLaneHeight = Math.floor(availableHeight / Math.max(1, visibleRows.length));
      state.laneHeight = Math.min(state.maxLaneHeight, Math.max(state.minLaneHeight, fittedLaneHeight));
      const totalHeight = visibleRows.length * state.laneHeight;
      const targetWidth = Math.floor(canvasWidth * dpr);
      const targetHeight = Math.max(Math.floor(totalHeight * dpr), 1);
      if (forceResize || timelineCanvas.width !== targetWidth || timelineCanvas.height !== targetHeight) {
        timelineCanvas.width = targetWidth;
        timelineCanvas.height = targetHeight;
      }
      timelineCanvas.style.width = `${Math.floor(canvasWidth)}px`;
      timelineCanvas.style.height = `${Math.floor(totalHeight)}px`;
      drawOverview();
      drawTimeline(visibleRows);
    }

    function filteredThreadOrder() {
      const query = threadFilter.value.trim().toLowerCase();
      if (!query) return state.threadOrder.slice();
      return state.threadOrder.filter(tid => {
        const thread = state.threads.get(tid);
        return thread && thread.name.toLowerCase().includes(query);
      });
    }

    function drawOverview() {
      const width = overviewCanvas.clientWidth;
      const height = overviewCanvas.clientHeight;
      const targetWidth = Math.floor(width * dpr);
      const targetHeight = Math.floor(height * dpr);
      if (overviewCanvas.width !== targetWidth || overviewCanvas.height !== targetHeight) {
        overviewCanvas.width = targetWidth;
        overviewCanvas.height = targetHeight;
      }
      overviewCanvas.style.width = `${Math.floor(width)}px`;
      overviewCanvas.style.height = `${Math.floor(height)}px`;
      const ctx = overviewCanvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, width, height);
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.strokeRect(snap(0.5), snap(0.5), snap(width - 1), snap(height - 1));

      const duration = state.maxMicros - state.minMicros;
      if (duration <= 0) return;

      const timelineStartX = state.carrierLabelWidth + state.eventLabelWidth + state.labelGap;
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.fillRect(0, 0, timelineStartX, height);
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.moveTo(snap(timelineStartX + 0.5), 0);
      ctx.lineTo(snap(timelineStartX + 0.5), height);
      ctx.stroke();
      ctx.fillStyle = 'rgba(217, 119, 6, 0.3)';
      ctx.fillRect(timelineStartX, snap(height / 2 - 10), width - timelineStartX, 20);

      if (state.selection) {
        const x1 = timelineStartX + ((state.selection.start - state.minMicros) / duration) * (width - timelineStartX);
        const x2 = timelineStartX + ((state.selection.end - state.minMicros) / duration) * (width - timelineStartX);
        ctx.fillStyle = 'rgba(15, 118, 110, 0.25)';
        ctx.fillRect(Math.min(x1, x2), 0, Math.abs(x2 - x1), height);
        const selDuration = Math.abs(state.selection.end - state.selection.start);
        const selLabel = formatDuration(selDuration);
        ctx.fillStyle = 'rgba(29, 27, 22, 0.85)';
        ctx.font = '12px "JetBrains Mono", "IBM Plex Mono", monospace';
        ctx.fillText(selLabel, Math.min(x1, x2) + 6, snap(height / 2 - 18));
      }
    }

    function drawTimeline(visibleRows) {
      const ctx = timelineCanvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;
      const canvasWidth = timelineCanvas.width / dpr;
      const canvasHeight = timelineCanvas.height / dpr;
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);

      const duration = state.viewEnd - state.viewStart;
      if (duration <= 0) return;

      const laneHeight = state.laneHeight;
      const minDur = Number(minDuration.value) || 0;
      const scrollTop = scrollArea.scrollTop;
      const viewTop = Math.floor(scrollTop / laneHeight);
      const viewBottom = Math.min(visibleRows.length, Math.ceil((scrollTop + scrollArea.clientHeight) / laneHeight));
      const carrierWidth = state.carrierLabelWidth;
      const eventWidth = state.eventLabelWidth;
      const labelGap = state.labelGap;
      const timelineStartX = carrierWidth + eventWidth + labelGap;
      const width = canvasWidth - timelineStartX;

      ctx.strokeStyle = 'rgba(0,0,0,0.05)';
      for (let i = viewTop; i <= viewBottom; i++) {
        const y = snap(i * laneHeight + 0.5);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvasWidth, y);
        ctx.stroke();
      }

      const groupSize = (state.events.length || 1) + 1;
      for (let i = 0; i < visibleRows.length; i++) {
        const row = visibleRows[i];
        if (row.type !== 'carrier') continue;
        const yStart = snap(i * laneHeight);
        const yEnd = Math.min((i + groupSize) * laneHeight, visibleRows.length * laneHeight);
        ctx.fillStyle = carrierColor(row.tid);
        ctx.fillRect(0, yStart, 6, yEnd - yStart);
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.beginPath();
        ctx.moveTo(0, snap(yStart + 0.5));
        ctx.lineTo(canvasWidth, snap(yStart + 0.5));
        ctx.stroke();
      }

      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.beginPath();
      ctx.moveTo(snap(timelineStartX + 0.5), snap(viewTop * laneHeight));
      ctx.lineTo(snap(timelineStartX + 0.5), snap(viewBottom * laneHeight));
      ctx.stroke();

      ctx.fillStyle = '#1d1b16';
      ctx.font = '12px "JetBrains Mono", "IBM Plex Mono", monospace';
      ctx.textBaseline = 'middle';

      for (let i = viewTop; i < viewBottom; i++) {
        const row = visibleRows[i];
        const thread = state.threads.get(row.tid);
        const y = snap(i * laneHeight + 1);
        if (row.type === 'carrier') {
          ctx.fillStyle = '#1d1b16';
          ctx.fillText(thread.name, 8, snap(y + (laneHeight - 4) / 2));
          continue;
        }
        ctx.fillStyle = '#4b463d';
        ctx.fillText(state.events[row.eventIdx], carrierWidth + 6, snap(y + (laneHeight - 4) / 2));
        drawEventLane(ctx, thread, row.eventIdx, timelineStartX, y, Math.max(2, laneHeight - 4), minDur, width);
      }
    }

    function drawEventLane(ctx, thread, eventIdx, offsetX, y, height, minDur, width) {
      const duration = state.viewEnd - state.viewStart;
      const s = thread.s;
      const d = thread.d;
      const n = thread.n;
      const baseY = snap(y);
      for (let i = 0; i < s.length; i++) {
        if (n[i] !== eventIdx) continue;
        const start = s[i];
        const dur = d[i];
        if (dur < minDur) continue;
        const end = start + dur;
        if (end < state.viewStart || start > state.viewEnd) continue;
        if (!state.eventEnabled[n[i]]) continue;
        const rawX1 = offsetX + ((start - state.viewStart) / duration) * width;
        const rawX2 = offsetX + ((end - state.viewStart) / duration) * width;
        let clampedX1 = Math.max(offsetX, Math.min(offsetX + width, rawX1));
        let clampedX2 = Math.max(offsetX, Math.min(offsetX + width, rawX2));
        if (clampedX2 < clampedX1) {
          const tmp = clampedX1;
          clampedX1 = clampedX2;
          clampedX2 = tmp;
        }
        let color = eventColor(n[i]);
      if (state.events[n[i]] === VT_RUN_EVENT_NAME || state.events[n[i]] === VT_SUBMIT_EVENT_NAME) {
          const isPoller = thread.p[i] === 1 || thread.p[i] === true;
          const isEventLoop = thread.el[i] === 1 || thread.el[i] === true;
          const isImmediate = thread.im[i] === 1 || thread.im[i] === true;
          if (isEventLoop) {
            color = VT_RUN_COLORS.eventLoop;
          } else if (isPoller && isImmediate) {
            color = VT_RUN_COMBO;
          } else if (isPoller) {
            color = VT_RUN_COLORS.poller;
          } else if (isImmediate) {
            color = VT_RUN_COLORS.immediate;
          }
        }
        ctx.fillStyle = color;
        const barWidth = Math.max(1, snap(clampedX2 - clampedX1));
        const barHeight = Math.max(1, snap(height));
        const maxBarX = offsetX + width - barWidth;
        const barX = snap(Math.max(offsetX, Math.min(maxBarX, clampedX1)));
        ctx.fillRect(barX, baseY, barWidth, barHeight);
        ctx.strokeStyle = 'rgba(0,0,0,0.45)';
        ctx.beginPath();
        ctx.moveTo(barX + 0.5, baseY);
        ctx.lineTo(barX + 0.5, baseY + barHeight);
        if (barWidth > 2) {
          ctx.moveTo(barX + barWidth - 0.5, baseY);
          ctx.lineTo(barX + barWidth - 0.5, baseY + barHeight);
        }
        ctx.stroke();
      }
    }

    function timeToX(time, width) {
      return ((time - state.minMicros) / (state.maxMicros - state.minMicros)) * width;
    }

    overviewCanvas.addEventListener('mousedown', (event) => {
      if (!state.threadOrder.length) return;
      const rect = overviewCanvas.getBoundingClientRect();
      const startX = event.clientX - rect.left;
      const timelineStartX = state.carrierLabelWidth + state.eventLabelWidth + state.labelGap;
      const clampedX = Math.max(timelineStartX, Math.min(rect.width, startX));
      const startTime = state.minMicros + ((clampedX - timelineStartX) / (rect.width - timelineStartX)) * (state.maxMicros - state.minMicros);
      state.selection = { start: startTime, end: startTime };
      const onMove = (e) => {
        const x = e.clientX - rect.left;
        const clampedMoveX = Math.max(timelineStartX, Math.min(rect.width, x));
        const time = state.minMicros + ((clampedMoveX - timelineStartX) / (rect.width - timelineStartX)) * (state.maxMicros - state.minMicros);
        state.selection.end = time;
        drawOverview();
      };
      const onUp = () => {
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
      };
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
    });

    timelineCanvas.addEventListener('wheel', (event) => {
      if (!state.threadOrder.length) return;
      event.preventDefault();
      const rect = timelineCanvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const timelineStartX = state.carrierLabelWidth + state.eventLabelWidth + state.labelGap;
      if (mouseX < timelineStartX) return;
      const viewWidth = rect.width;
      const zoomFactor = event.deltaY < 0 ? 0.8 : 1.25;
      const duration = state.viewEnd - state.viewStart;
      const zoomCenter = state.viewStart + ((mouseX - timelineStartX) / (viewWidth - timelineStartX)) * duration;
      const newDuration = Math.max(100, duration * zoomFactor);
      state.viewStart = zoomCenter - ((mouseX - timelineStartX) / (viewWidth - timelineStartX)) * newDuration;
      state.viewEnd = state.viewStart + newDuration;
      if (state.viewStart < state.minMicros) {
        state.viewStart = state.minMicros;
        state.viewEnd = state.viewStart + newDuration;
      }
      if (state.viewEnd > state.maxMicros) {
        state.viewEnd = state.maxMicros;
        state.viewStart = state.viewEnd - newDuration;
      }
      redraw();
    }, { passive: false });

    let dragState = null;
    timelineCanvas.addEventListener('mousedown', (event) => {
      if (!state.threadOrder.length) return;
      const rect = timelineCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const timelineStartX = state.carrierLabelWidth + state.eventLabelWidth + state.labelGap;
      if (x >= timelineStartX) return;
      const y = event.clientY - rect.top + scrollArea.scrollTop;
      const laneIndex = Math.floor(y / state.laneHeight);
      const row = state.visibleRows[laneIndex];
      if (!row) return;
      const groupSize = (state.events.length || 1) + 1;
      dragState = {
        tid: row.tid,
        groupSize,
      };
      event.preventDefault();
    });

    let isPanning = false;
    let panStartX = 0;
    let panStartView = 0;
    timelineCanvas.addEventListener('mousedown', (event) => {
      if (!state.threadOrder.length) return;
      const timelineStartX = state.carrierLabelWidth + state.eventLabelWidth + state.labelGap;
      if (event.clientX - timelineCanvas.getBoundingClientRect().left < timelineStartX) return;
      isPanning = true;
      panStartX = event.clientX;
      panStartView = state.viewStart;
    });
    window.addEventListener('mousemove', (event) => {
      if (dragState) {
        const rect = timelineCanvas.getBoundingClientRect();
        const y = event.clientY - rect.top + scrollArea.scrollTop;
        const targetIndex = Math.max(0, Math.min(state.threadOrder.length - 1, Math.floor(y / (state.laneHeight * dragState.groupSize))));
        const currentIndex = state.threadOrder.indexOf(dragState.tid);
        if (currentIndex !== -1 && targetIndex !== currentIndex) {
          state.threadOrder.splice(currentIndex, 1);
          state.threadOrder.splice(targetIndex, 0, dragState.tid);
          redraw(true);
        }
        return;
      }
      if (!isPanning) return;
      const rect = timelineCanvas.getBoundingClientRect();
      const delta = event.clientX - panStartX;
      const duration = state.viewEnd - state.viewStart;
      const timelineStartX = state.carrierLabelWidth + state.eventLabelWidth + state.labelGap;
      const deltaTime = (delta / (rect.width - timelineStartX)) * duration;
      state.viewStart = panStartView - deltaTime;
      state.viewEnd = state.viewStart + duration;
      if (state.viewStart < state.minMicros) {
        state.viewStart = state.minMicros;
        state.viewEnd = state.viewStart + duration;
      }
      if (state.viewEnd > state.maxMicros) {
        state.viewEnd = state.maxMicros;
        state.viewStart = state.viewEnd - duration;
      }
      redraw();
    });
    window.addEventListener('mouseup', () => {
      dragState = null;
      isPanning = false;
    });

    timelineCanvas.addEventListener('mousemove', (event) => {
      if (!state.threadOrder.length) return;
      const rect = timelineCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top + scrollArea.scrollTop;
      const laneIndex = Math.floor(y / state.laneHeight);
      const row = state.visibleRows[laneIndex];
      if (!row) {
        tooltip.style.opacity = 0;
        return;
      }
      if (row.type !== 'event') {
        tooltip.style.opacity = 0;
        return;
      }
      const tid = row.tid;
      if (tid == null) {
        tooltip.style.opacity = 0;
        return;
      }
      const thread = state.threads.get(tid);
      const timelineStartX = state.carrierLabelWidth + state.eventLabelWidth + state.labelGap;
      if (x < timelineStartX) {
        tooltip.style.opacity = 0;
        return;
      }
      const time = state.viewStart + ((x - timelineStartX) / (rect.width - timelineStartX)) * (state.viewEnd - state.viewStart);
      const eventIdx = findEvent(thread, time, row.eventIdx);
      if (eventIdx < 0) {
        tooltip.style.opacity = 0;
        return;
      }
      const eventName = state.events[thread.n[eventIdx]];
      const start = thread.s[eventIdx];
      const dur = thread.d[eventIdx];
      const vtid = thread.v[eventIdx];
      const isPoller = thread.p[eventIdx];
      const isEventLoop = thread.el[eventIdx];
      const isImmediate = thread.im[eventIdx];
      const canBlock = thread.b[eventIdx];
      const tasksExecuted = thread.te[eventIdx];
      const queueDepthBefore = thread.q0[eventIdx];
      const queueDepthAfter = thread.q1[eventIdx];
      const ioEventsHandled = thread.io[eventIdx];
      const tasksHandled = thread.th[eventIdx];
      const submitterTid = thread.st[eventIdx];

      // Build tooltip dynamically based on available fields
      let tooltipText =
        `Carrier: ${thread.name}\n` +
        `Event: ${eventName}\n` +
        `Start: ${formatNanosRaw(start)}\n` +
        `Duration: ${formatNanosRaw(dur)}`;

      if (vtid) {
        tooltipText += `\nVirtualThreadId: ${vtid}`;
      }
      if (isPoller != null) {
        tooltipText += `\nIsPoller: ${isPoller ? 'true' : 'false'}`;
      }
      if (isEventLoop != null) {
        tooltipText += `\nIsEventLoop: ${isEventLoop ? 'true' : 'false'}`;
      }
      if (isImmediate != null) {
        tooltipText += `\nImmediate: ${isImmediate ? 'true' : 'false'}`;
      }
      if (canBlock != null) {
        tooltipText += `\nCanBlock: ${canBlock ? 'true' : 'false'}`;
      }
      if (tasksExecuted != null) {
        tooltipText += `\nTasksExecuted: ${tasksExecuted}`;
      }
      if (queueDepthBefore != null || queueDepthAfter != null) {
        const beforeText = queueDepthBefore != null ? queueDepthBefore : '?';
        const afterText = queueDepthAfter != null ? queueDepthAfter : '?';
        tooltipText += `\nQueueDepth: ${beforeText} -> ${afterText}`;
      }
      if (ioEventsHandled != null) {
        tooltipText += `\nIoEventsHandled: ${ioEventsHandled}`;
      }
      if (tasksHandled != null) {
        tooltipText += `\nTasksHandled: ${tasksHandled}`;
      }
      if (submitterTid != null) {
        tooltipText += `\nSubmitterThreadId: ${submitterTid}`;
      }

      tooltip.textContent = tooltipText;
      tooltip.style.left = `${event.clientX}px`;
      tooltip.style.top = `${event.clientY}px`;
      tooltip.style.opacity = 1;
    });
    timelineCanvas.addEventListener('mouseleave', () => {
      tooltip.style.opacity = 0;
    });

    function findEvent(thread, time, eventIdxFilter) {
      const s = thread.s;
      const d = thread.d;
      const n = thread.n;
      let lo = 0;
      let hi = s.length - 1;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const start = s[mid];
        const end = start + Math.max(1, d[mid]);
        if (time < start) {
          hi = mid - 1;
        } else if (time > end) {
          lo = mid + 1;
        } else {
          if (eventIdxFilter == null || n[mid] === eventIdxFilter) {
            return mid;
          }
          for (let i = mid - 1; i >= 0 && i >= mid - 8; i--) {
            const s1 = s[i];
            const e1 = s1 + Math.max(1, d[i]);
            if (time < s1) break;
            if (time <= e1 && n[i] === eventIdxFilter) return i;
          }
          for (let i = mid + 1; i < s.length && i <= mid + 8; i++) {
            const s1 = s[i];
            const e1 = s1 + Math.max(1, d[i]);
            if (time > e1 && time > s1) continue;
            if (time >= s1 && time <= e1 && n[i] === eventIdxFilter) return i;
          }
          return -1;
        }
      }
      return -1;
    }

    function buildVisibleRows(visibleThreads) {
      const rows = [];
      for (const tid of visibleThreads) {
        rows.push({ type: 'carrier', tid });
        for (let i = 0; i < state.events.length; i++) {
          rows.push({ type: 'event', tid, eventIdx: i });
        }
      }
      return rows;
    }

    window.addEventListener('resize', () => redraw(true));
    scrollArea.addEventListener('scroll', () => redraw());
  </script>
</body>
</html>
